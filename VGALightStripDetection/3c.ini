; 指定打开哪个摄像头
[Camera]
Index=0
Exposure=-5

; 从摄像头获取画面的大小
[Frame]
Width=640
Hight=480

; 从Frame 中截取的画面大小
[RectFrame]
X=164
Y=2
Width=113
Hight=477

[AgingSetting]
; 调试模式会多一些debug窗口
DebugMode =0

; 持续测试 100000 次
AgingTime =200

; 灯珠闪烁的间隔速度ms
IntervalTime =100

; 最小轮廓的最小矩形面积
MinContoursArea =50

; 轮廓与轮廓之间的最小间隔，小于此间隔，则两个轮廓会被视为同属一个大轮廓中
MinContoursSpace =50

; 0 表示不需要重新拾取显卡灯带区域； 1 表示需要重新拾取一次灯带区域，拾取后的ROI会覆盖[RectFrame]数据
ResetRectFrame =0

; 随机灭灯设置，取值范围[0, 255)；取消随机灭灯置为0
RandomShutDownLedNum =0

; 测试完毕后， 定时关机，单位秒， -1 表示不关机, -2 表示执行完后重启
ShutDownDelayTime =-1

; 自适应阈值算法中，参与计算的邻域块大小，为奇数
AdaptiveThresholdArgBlockSize =101

; 自适应阈值算法中，对计算出来的阈值进行调节的常数delta
AdaptiveThresholdArgC =-9

; 侦测到某颗灯Faile 后， 再进行N次测试，看是否真的是Faile了
RecheckFaileLedTime =0


[LED]
; 显卡灯带中灯珠的数量
Count=15
;BLUE = 0, GREEN = 1, RED = 2, WHITE = 3, AllColor = 4
;StartColor, StopColor ∈ [0, 4)
StartColor =0
StopColor =3

; 是否需要显示一个Trackbar来调节灯带HSV颜色阈值
[TrackBarWindow]
IsShow=0

[ThresholdB]
t =50
p =45

[ThresholdG]
t =50
p =45

[ThresholdR]
t =50
p =45

[ThresholdW]
t =50
p =45


; 处理Red色灯时，需要用到的HSV阈值
;{156, 180, 159, 180, 43, 255, 149, 255, 46, 255, 148, 255} // Red
; (Lh,Hh) ∈[156, 180], Lh < Hh
; (Ls,Hs) ∈[43, 255], Ls < Hs
; (Lv,Hv) ∈[46, 255], Lv < Hv
[RedThreshold]
Lh=2
Hh=180
Ls=0
Hs=255
Lv=0
Hv=255

;{35, 77, 35, 77, 43, 255, 43, 255, 46, 255, 136, 255}	// Green
; 处理Green色灯时，需要用到的HSV阈值
; (Lh,Hh) ∈[35, 77], Lh < Hh
; (Ls,Hs) ∈[43, 255], Ls < Hs
; (Lv,Hv) ∈[46, 255], Lv < Hv
[GreenThreshold]
Lh=35
Hh=155
Ls=0
Hs=255
Lv=0
Hv=255

;{100, 124, 100, 124, 43, 255, 43, 255, 46, 255, 176, 255} // Blue
; 处理Blue色灯时，需要用到的HSV阈值
; (Lh,Hh) ∈[100, 124], Lh < Hh
; (Ls,Hs) ∈[43, 255], Ls < Hs
; (Lv,Hv) ∈[46, 255], Lv < Hv
[BlueThreshold]
Lh=35
Hh=124
Ls=0
Hs=255
Lv=0
Hv=255

; 处理White色灯时，需要用到的HSV阈值
;{0,   180, 125, 180, 0,  30,  2,   30,  221, 255, 221, 255} // White
; (Lh,Hh) ∈[0,   180], Lh < Hh
; (Ls,Hs) ∈[0,  30], Ls < Hs
; (Lv,Hv) ∈[221, 255], Lv < Hv
[WhiteThreshold]
Lh=0
Hh=180
Ls=2
Hs=30
Lv=221
Hv=255
